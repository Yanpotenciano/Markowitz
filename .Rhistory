odds$vencedor=0
odds$perdedor=0
for (i in 1 :length(odds$FTR)) {
if(odds$FTR[i] == "H"){
odds$vencedor[i] = odds$HomeTeam[i]
odds$perdedor[i] = odds$AwayTeam[i]
} else if(odds$FTR[i] == "D") {
odds$vencedor[i] = "Empate"
odds$perdedor[i] = "Empate"
} else if(odds$FTR[i] == "A"){
odds$vencedor[i] = odds$AwayTeam[i]
odds$perdedor[i] = odds$HomeTeam[i]
}
}
Times = data.frame(x = c(cbind(unique(odds$HomeTeam),unique(odds$AwayTeam))))
Times$pontos = 0
Times$npartidas = 0
Times$x = as.character(Times$x)
# tentando estabelecer numero de rodadas então não iremos separar um time quando ele joga fora e dentro de casa
# Filtrar pra cada time e elencar rodadas a partir disso a partir da data
PC = list()
PF= list()
i=1
PAxB = list()
for (i in 1:length(odds$FTR)) {
PC[[i]]= c(1/3,1/3,1/3)
PF[[i]]= c(1/3,1/3,1/3)
}
#odds$vencedor[1]==odds$AwayTeam[1]
#
#PF[[21]] = (p*PF[[which(odds$AwayTeam[21]==odds$AwayTeam)]] + Times$r[(which(Times$x[k]== odds$HomeTeam))[1]]*vitoria)/ (p + Times$r[(which(Times$x[1]== odds$HomeTeam))[1]])
#b = which(odds$AwayTeam[21]==odds$AwayTeam)
jf =0
jc=0
#
rc = list()
rf= list()
for (i in 1: length(odds$FTR) ) {
bc = which(odds$HomeTeam[i]==odds$HomeTeam)
jc = which(i == bc)-1
bf = which(odds$AwayTeam[i]==odds$AwayTeam)
jf = which(i == bf)-1
rc[[i]] = Times$r[(which(Times$x== odds$AwayTeam[bc[jc]]))]
rf[[i]] = Times$r[(which(Times$x== odds$HomeTeam[bf[jf]]))]
if( odds$vencedor[i]== odds$HomeTeam[i]){
s = which(odds$HomeTeam[i] == Times$x)
Times$pontos[s] = Times$pontos[s]+3
Times$npartidas[s] = Times$npartidas[s] +1
v = which(odds$AwayTeam[i] == Times$x)
Times$npartidas[v] = Times$npartidas[v]+1
Times$r = Times$pontos/ (Times$npartidas*3)
if(jc ==0 & jf==0){
PC[[i]] = PC[[i]]
PF[[i]] = PF[[i]]
} else if(jc ==0 & jf!=0){
PF[[i]] = (p*PF[[which(odds$AwayTeam[i]==odds$AwayTeam)[jf]]] + (1-rf[[i]])*derrota)/(p + (1-rf[[i]]))
PC[[i]] = PC[[i]]
}
else if(jc !=0 & jf==0){
PC[[i]] = (p*PC[[which(odds$HomeTeam[i]==odds$HomeTeam)[jc]]] + rc[[i]]*vitoria)/(p + rc[[i]])
PF[[i]] = PF[[i]]
} else{
PC[[i]] = (p*PC[[which(odds$HomeTeam[i]==odds$HomeTeam)[jc]]] + rc[[i]]*vitoria)/(p + rc[[i]])
PF[[i]] = (p*PF[[which(odds$AwayTeam[i]==odds$AwayTeam)[jf]]] + (1-rf[[i]])*derrota)/(p + (1-rf[[i]]))
}
}
else if( odds$vencedor[i]== odds$AwayTeam[i]){
s = which(odds$AwayTeam[i] == Times$x)
Times$pontos[s] = Times$pontos[s]+3
Times$npartidas[s] = Times$npartidas[s] +1
v = which(odds$HomeTeam[i] == Times$x)
Times$npartidas[v] = Times$npartidas[v]+1
Times$r = Times$pontos/ (Times$npartidas*3)
if(jc ==0 & jf==0){
PC[[i]] = PC[[i]]
PF[[i]] = PF[[i]]
} else if(jc ==0 & jf!=0){
PF[[i]] = (p*PF[[which(odds$AwayTeam[i]==odds$AwayTeam)[jf]]] + rf[[i]]*vitoria)/(p + rf[[i]])
}
else if(jc !=0 & jf==0){
PC[[i]] = (p*PC[[which(odds$HomeTeam[i]==odds$HomeTeam)[jc]]] + (1-rc[[i]])*derrota)/(p + (1-rc[[i]]))
PF[[i]] = PF[[i]]
} else{
PC[[i]] = (p*PC[[which(odds$HomeTeam[i]==odds$HomeTeam)[jc]]] + (1-rc[[i]])*derrota)/(p + (1-rc[[i]]))
PF[[i]] = (p*PF[[which(odds$AwayTeam[i]==odds$AwayTeam)[jf]]] + rf[[i]]*vitoria)/(p + rf[[i]])
}
}
else{
s2 = which(odds$HomeTeam[i] == Times$x)
Times$pontos[s2] = Times$pontos[s2]+1
Times$npartidas[s2] = Times$npartidas[s2] +1
s3 = which(odds$AwayTeam[i] == Times$x)
Times$pontos[s3] = Times$pontos[s3]+1
Times$npartidas[s3] = Times$npartidas[s3] +1
Times$r = Times$pontos/ (Times$npartidas*3)
if(jc ==0 & jf==0){
PC[[i]] = PC[[i]]
PF[[i]] = PF[[i]]
} else if(jc ==0 & jf!=0){
PF[[i]] = (p*PF[[which(odds$AwayTeam[i]==odds$AwayTeam)[jf]]] + rf[[i]]*empate)/(p + rf[[i]])
PC[[i]] = PC[[i]]
}
else if(jc !=0 & jf==0){
PC[[i]] = (p*PC[[which(odds$HomeTeam[i]==odds$HomeTeam)[jc]]] + rc[[i]]*empate)/(p + rc[[i]])
PF[[i]] = PF[[i]]
} else{
PC[[i]] = (p*PC[[which(odds$HomeTeam[i]==odds$HomeTeam)[jc]]] + rc[[i]]*empate)/(p + rc[[i]])
PF[[i]] = (p*PF[[which(odds$AwayTeam[i]==odds$AwayTeam)[jf]]] + rf[[i]]*empate)/(p + rf[[i]])
}
}
PAxB[[i]] = c( (PC[[i]][1]+PF[[i]][3])/2,  (PC[[i]][2]+PF[[i]][2])/2 , (PC[[i]][3]+PF[[i]][1])/2 )
}
#t = data.frame(Prob_vitoria_mandante= 0 , Prob_vitoria_empate=0 , Prob_vitoria_visitante=0 )
Prob_vitoria_mandante= 0
Prob_vitoria_empate=0
Prob_vitoria_visitante=0
for (j in 1:380) {
Prob_vitoria_mandante[j] = PAxB[[j]][1]
Prob_vitoria_empate[j] = PAxB[[j]][2]
Prob_vitoria_visitante[j] = PAxB[[j]][3]
}
odds$Probmandante = Prob_vitoria_mandante
odds$Probempate = Prob_vitoria_empate
odds$Probvisitante = Prob_vitoria_visitante
linhas = 1:(length(odds$FTR)/2)
teste = odds[-linhas,]
teste$intervalo_empate = teste$Probmandante + teste$Probempate
# Simulação das apostas
# Considerando apos 19 rodadas
#num_aleatorio=0
i=1
teste$aposta =0
#teste$numero_simulado= 0
teste$lucro = 0
teste$retorno=0
for (i in 1:length(teste$FTR)) {
#  num_aleatorio[i]=runif(1, min=0, max=1)
#  teste$numero_simulado[i]= num_aleatorio[i]
if( teste$intervalo_empate[i] <= numero_simulado[i]){
teste$aposta[i] = "vitoria_visitante"
} else if( teste$Probmandante[i]<numero_simulado[i] & numero_simulado[i]<= teste$intervalo_empate[i]){
teste$aposta[i]= "empate"
} else{
teste$aposta[i] = "vitoria_mandante"
}
if(teste$aposta[i]== "vitoria_visitante" & teste$FTR[i] == "A"){
teste$retorno[i]= teste$PSA[i]*10
} else if(teste$aposta[i]== "empate" & teste$FTR[i] == "D" ) {
teste$retorno[i]= teste$PSD[i]*10
}
else if (teste$aposta[i]== "vitoria_mandante" & teste$FTR[i] == "H" ){
teste$retorno[i]= teste$PSH[i]*10
}
else{
teste$retorno[i]=0
}
teste$lucro = teste$retorno - 10
}
teste2 = filter(teste, teste$aposta != "vitoria_mandante")
# Buscando outra forma de apostar sem simulação , o metodo consiste em apostar no resultado em que a probabilidade
#do nosso modelo é mais distante da probabilidade do modelo da casa de apostas
# Modelo da casa de apostas pinnacle
Margem = (1/teste$PSH + 1/teste$PSD + 1/teste$PSA ) - 1
teste$Prob_pinnacle_mandantev = 1/teste$PSH - Margem/3
teste$Prob_pinnacle_empate = 1/teste$PSD - Margem/3
teste$Prob_pinnacle_visitantev = 1/teste$PSA - Margem/3
teste$aposta_pinnacle= 0
teste$retorno_pinnacle = 0
teste$lucro_pinnacle = 0
teste$intervalo_empate_pinnacle = teste$Prob_pinnacle_mandantev + teste$Prob_pinnacle_empate
i=1
for (i in 1:length(teste$FTR)) {
if( teste$intervalo_empate_pinnacle[i] <= numero_simulado[i]){
teste$aposta_pinnacle[i] = "vitoria_visitante"
} else if( teste$Prob_pinnacle_mandantev[i]<numero_simulado[i] & numero_simulado[i]<= teste$intervalo_empate_pinnacle[i]){
teste$aposta_pinnacle[i]= "empate"
} else{
teste$aposta_pinnacle[i] = "vitoria_mandante"
}
if(teste$aposta_pinnacle[i]== "vitoria_visitante" & teste$FTR[i] == "A"){
teste$retorno_pinnacle[i]= teste$PSA[i]*10
} else if(teste$aposta_pinnacle[i]== "empate" & teste$FTR[i] == "D" ) {
teste$retorno_pinnacle[i]= teste$PSD[i]*10
}
else if (teste$aposta_pinnacle[i]== "vitoria_mandante" & teste$FTR[i] == "H" ){
teste$retorno_pinnacle[i]= teste$PSH[i]*10
}
else{
teste$retorno_pinnacle[i]=0
}
teste$lucro_pinnacle = teste$retorno_pinnacle - 10
}
sum(teste$lucro_pinnacle)
teste2 = filter(teste, teste$aposta != "vitoria_mandante")
sum(teste2$lucro_pinnacle)
teste$difmandante = teste$Probmandante- teste$Prob_pinnacle_mandantev
teste$difempate =  teste$Probempate -teste$Prob_pinnacle_empate
teste$difvisitante = teste$Probvisitante-  teste$Prob_pinnacle_visitantev
teste$aposta_dif =0
teste$retorno_dif =0
teste$lucro_dif =0
for (i in 1:length(teste$FTR)) {
if(teste$difmandante[i]>teste$difempate[i] & teste$difmandante[i]>teste$difvisitante[i]){
teste$aposta_dif[i] = "vitoria_mandante"
} else if(teste$difmandante[i]<teste$difempate[i] & teste$difempate[i]>teste$difvisitante[i]){
teste$aposta_dif[i] = "empate"
} else{
teste$aposta_dif[i] = "vitoria_visitante"
}
if(teste$aposta_dif[i]== "vitoria_visitante" & teste$FTR[i] == "A"){
teste$retorno_dif[i]= teste$PSA[i]*10
} else if(teste$aposta_dif[i]== "empate" & teste$FTR[i] == "D" ) {
teste$retorno_dif[i]= teste$PSD[i]*10
}
else if (teste$aposta_dif[i]== "vitoria_mandante" & teste$FTR[i] == "H" ){
teste$retorno_dif[i]= teste$PSH[i]*10
}
else{
teste$retorno_dif[i]=0
}
teste$lucro_dif = teste$retorno_dif - 10
}
sum(teste$lucro_dif)
teste2 = filter(teste, teste$aposta != "vitoria_mandante")
sum(teste2$lucro_dif)
#write.xlsx(teste,"S3.xlsx")
a =0
a = data.frame(lucro_ufmg = sum(teste$lucro), lucro_pinnacle = sum(teste$lucro_pinnacle) , lucro_dif = sum(teste$lucro_dif ), lucro_ufmg_SM = sum(teste2$lucro), lucro_pinnacle_SM = sum(teste2$lucro_pinnacle) , lucro_dif_SM = sum(teste2$lucro_dif ))
#a = teste %>% select(HomeTeam, AwayTeam,FTR,PSH,PSD,PSA,Probmandante,Probempate,Probvisitante,intervalo_empate,aposta)
return(a)
}
s1 = f1(0.0001,numero_simulado)
s2 = f1(0.25, numero_simulado)
s3 = f1(0.5, numero_simulado)
s4= f1(0.75, numero_simulado)
s5 = f1(2, numero_simulado)
s6 = f1(5, numero_simulado)
s7 = f1(20, numero_simulado)
s = rbind(s1,s2,s3,s4,s5,s6)
#stdlib
rm(list=ls(all=TRUE))
library(plotly)
library(fPortfolio)
library(BatchGetSymbols)
# todas as fun??es que subscrevem tidyverse devem vir antes
library(tidyverse)
library(readxl)
library(lubridate)
library(mondate)
library(gdata)
library(lpSolve)
library(lpSolveAPI)
library(ggplot2)
library(openxlsx)
library(tseries)
require(lubridate)
library(forecast)
setwd("Z:/GERENCIA/INVESTIMENTOS/MARKOWITZ-MAIN")
Ano_base = 2022
Mes_base = 5
Meses_calculados = 6
Data_base = dmy("01/05/2022")
fund_register = "Fronteira_Markowitz_v14.xlsm"
cvm_link = "http://dados.cvm.gov.br/dados/FI/DOC/INF_DIARIO/DADOS/inf_diario_fi_"
cvm_link2 = "inf_diario_fi_"
suffix_cvm = function(Meses_calculados,Data_base)
{
Anos=0
Meses=0
#Starting dates
Meses[1] = format(mondate(Data_base, "%m"))
Anos[1] = format(mondate(Data_base, "%Y"))
#Creating suffix to be used in cvm link
suffix = rep(0, Meses_calculados)
suffix[1] = paste0(Anos[1], Meses[1])
for (i in 1:(Meses_calculados-1))
{
Meses[i+1] = format(mondate(Data_base- months(i), "%m"))
Anos[i+1] = format(mondate(Data_base- months(i), "%Y"))
suffix[i+1] = paste0(Anos[i+1], Meses[i+1])
}
return(suffix)
}
Download_CVM = function(n, suffix)
{
#Temporary file to be created
tmp = 'tmp.zip'
lista = list()
myurl = paste0(cvm_link, suffix,".zip")
mydta = paste0(cvm_link2, suffix,".csv")
for (i in 1:n)
{
download.file(url = myurl[i], destfile = tmp)
unzip(tmp)
# lista[[i]] = read_delim(mydta[i],
#                         delim = ";",
#                         escape_double = FALSE,
#                         col_types = cols(DT_COMPTC = col_character()),
#                         trim_ws = TRUE)
}
lista = do.call(rbind, lapply(list.files(path = ".", pattern = "csv"),
read.csv2))
return(lista)
}
Read_CVM = function(n, suffix)
{
lista = list()
mydta = vector()
lista = do.call(rbind.data.frame, lapply(list.files(path = ".", pattern = "csv"),
read.csv, sep = ";"))
return(lista)
}
read_funds = function(fund_register)
{
Fundos <- read_excel(fund_register, sheet = "CADASTRO")
Fundos <- Fundos %>%
select(`Nome do fundo`,
CNPJ,
Bench,
Resgate,
`Taxa Administrativa`,
`Grau de Risco`,
`Enquadramento Legal`,
`Limite do Enquadramento Legal`,
Segmento
) %>%
rename.vars(from = "CNPJ",
to = "CNPJ_FUNDO")
Fundos$Restricao_segmento= Fundos$`Limite do Enquadramento Legal`
Fundos$Data_analise = paste0("0",Mes_base,"/",Ano_base)
#Blacklist
Fundos = filter(Fundos, Fundos$CNPJ_FUNDO != "35.292.597/0001-70")
return(Fundos)
}
Analise_CNPJ = function(my_dt,Fundos)
{
my_dt = inner_join(my_dt, Fundos, by= ("CNPJ_FUNDO"="CNPJ_FUNDO"))
CNPJS = unique(my_dt$CNPJ_FUNDO)
my_dt = my_dt[(order(as.Date(my_dt$DT_COMPTC, format="%Y/%m/%d"))),]
my_dt2 = list()
for (i in 1:length(CNPJS))
my_dt2[[i]] = filter(my_dt , my_dt$CNPJ_FUNDO == CNPJS[i])
for (j in 1:length(my_dt2))
{
for (i in 1:length(my_dt2[[j]]$CNPJ_FUNDO))
{
if(length(my_dt2[[j]]$CNPJ_FUNDO) == i)
my_dt2[[j]]$rentabilidade[i] = 0
else
my_dt2[[j]]$rentabilidade[i] = (my_dt2[[j]]$VL_QUOTA[i]-my_dt2[[j]]$VL_QUOTA[i+1])/my_dt2[[j]]$VL_QUOTA[i+1]
}
}
return(my_dt2)
}
# Download dos arquivos do site da cvm
suffix = suffix_cvm(Meses_calculados, Data_base)
#my_dt = Download_CVM(Meses_calculados, suffix)
my_dt = Read_CVM(Meses_calculados, suffix)
# Step ?
Fundos = read_funds(fund_register)
my_dt = Analise_CNPJ(my_dt,Fundos)
#test_data_idx <- function(date)
#  {
#  y <- year(as.Date.character(date)) == 2022
#  m <- month(as.Date.character(date)) == 2
#  return(m & y)
#  }
#training_data_idx <- function(date)
#{
#  y <- year(as.Date.character(date)) == 2022
#  m <- month(as.Date.character(date)) == 2
#  return(!(m & y))
#}
serie= list()
teste = list()
decisao = 0
decisao2 = 0
decisao3 = 0
decisao_final = 0
normalidade = 0
normalidade2 = 0
s=0
#intervalo = length(my_dt) -1
dados_treino = list()
dados_teste = list()
acuracia = list()
previsao = list()
for (i in 1:length(my_dt)) {
serie[[i]] = auto.arima(ts(my_dt[[i]]$VL_QUOTA), allowdrift = TRUE,stepwise=TRUE,method="ML")
teste[[i]] = Box.test(residuals(arima(ts(my_dt[[i]]$VL_QUOTA), order =arimaorder(serie[[i]]),method="ML" )),
type="Ljung-Box")
s[i] = arimaorder(serie[[i]])[2]
if(s[i] !=0){
teste[[i]]$dickey_fuller = adf.test(diff(ts(my_dt[[i]]$VL_QUOTA), differences = s[i]))
teste[[i]]$pptest = pp.test(diff(ts(my_dt[[i]]$VL_QUOTA),differences = s[i]))
} else{
teste[[i]]$dickey_fuller = adf.test(ts(my_dt[[i]]$VL_QUOTA))
teste[[i]]$pptest = pp.test(ts(my_dt[[i]]$VL_QUOTA))
}
teste[[i]]$normalidade = jarque.bera.test(residuals(serie[[i]]))
teste[[i]]$normalidade2 = shapiro.test(residuals(serie[[i]]))
decisao[i] = if_else(teste[[i]]$p.value > 0.05 , "Não Rejeita independencia", "Rejeita independencia")
decisao2[i] = if_else(teste[[i]]$dickey_fuller$p.value > 0.05 , "Não Rejeita estacionariedade", "Rejeita estacionariedade")
decisao3[i] = if_else(teste[[i]]$pptest$p.value > 0.05 , " Rejeita estacionariedade", "Rejeita não estacionariedade")
normalidade[i] = if_else(teste[[i]]$normalidade$p.value > 0.05 , "Não Rejeita normalidade dos erros", "Rejeita normalidade dos erros")
normalidade2[i] = if_else(teste[[i]]$normalidade2$p.value > 0.05 , "Não Rejeita normalidade dos erros", "Rejeita normalidade dos erros")
previsao[[i]] = forecast(serie[[i]],h=147, level=95)
#acuracia[[i]]=  accuracy(forecast(serie[[i]],h=30, level=95),dados_teste[[i]])
}
table(decisao)
table(decisao2)
table(decisao3)
#
10/52
1/52
#19,2% das series foi rejeitada a independencia
#92,3% das series foi rejeitada a não estacionariedade, então 1,92% são não estacionarios.
table(normalidade)
table(normalidade2)
10/52
#47/52
#19,2% das series foi rejeitada a hipotese de normalidade dos erros
fstat= list()
homoc= 0
i=1
for (i in 1:length(serie)) {
m = length(serie[[i]]$residuals)/2
a1 = serie[[i]]$residuals[1:m]
a2 = serie[[i]]$residuals[(m+1):length(serie[[i]]$residuals)]
f= sum(a1^2/m)/(sum(a2^2/(m)))
fstat[[i]] =qf(0.95,m,m)
homoc[i] = if_else(fstat[[i]] < f , " Rejeita homocedasticidade", "Não rejeita homocedasticidade")
}
table(homoc)
8/52
#15,3% das series não sao homocedasticas
Restricoes = function(f,condicao)
{
# f corresponde a coluna do enquadramento ou ao segmento
# condição corresponde ao enquadramento do fundo
vetor = which(f == condicao)
return(vetor)
}
otimizacao = function(my_dt, Fundos)
{
Desvio = 0
dt = 0
rentabilidademedia=0
my_data = 0
for (i in 1:length(my_dt))
{
rentabilidademedia[i] = mean(my_dt[[i]]$rentabilidade)
Desvio[i] = sd(my_dt[[i]]$rentabilidade)
dt = filter(my_dt[[i]], my_dt[[i]]$DT_COMPTC == max(my_dt[[i]]$DT_COMPTC))
my_data[i]= dt$VL_PATRIM_LIQ[1]
}
for (i in 1:length(my_dt))
my_dt[[i]] = my_dt[[i]] %>% select(rentabilidade)
teste = my_dt[[1]]
for (j in 2:length(my_dt))
teste = cbind(teste,my_dt[[j]])
for (k in 1:length(Fundos$`Nome do fundo`))
names(teste)[k]<- unique(Fundos$`Nome do fundo`)[k]
rentabilidade <- as.timeSeries(teste) #tangecyPortfolio() only accepts time.series object.
constraints <- c('maxsumW[Restricoes(Fundos$`Enquadramento Legal`,"Art. 7º, IV, a")]=0.39',
'maxsumW[Restricoes(Fundos$`Enquadramento Legal`,"Art. 8º, I, a")]=0.29',
'maxsumW[Restricoes(Fundos$`Enquadramento Legal`,"Art. 8º, II, a")]=0.19',
'maxsumW[Restricoes(Fundos$`Enquadramento Legal`,"Art. 8º, III")]=0.09',
'maxsumW[Restricoes(Fundos$`Enquadramento Legal`,"Art. 9º-A, III")]=0.09',
'maxsumW[Restricoes(Fundos$`Enquadramento Legal`,"Art. 7º, VII, b")]=0.04',
'maxsumW[Restricoes(Fundos$`Enquadramento Legal`,"Art. 7º, III")]=0.59',
'maxsumW[Restricoes(Fundos$Segmento,"Renda variável")]=0.29',
'maxsumW[Restricoes(Fundos$Segmento,"Exterior")]=0.09')
portfolio.eficiente <- tangencyPortfolio(rentabilidade, spec = portfolioSpec(), constraints)
Markowitz = data.frame(Fundos = Fundos$`Nome do fundo`,
Bench = Fundos$Bench,
Resgate = Fundos$Resgate,
Taxa_Administrativa =Fundos$`Taxa Administrativa`,
CNPJ = Fundos$CNPJ_FUNDO,
Grau_de_Risco = Fundos$`Grau de Risco`,
Enquadramento_legal = Fundos$`Enquadramento Legal`,
Limite_do_Enquadramento_Legal = Fundos$`Limite do Enquadramento Legal`,
Segmento = Fundos$Segmento,
Restricao_segmento = Fundos$Restricao_segmento,
Max_recursos = 0.14*my_data,
Rentabilidade_Media = rentabilidademedia,
Desvio = Desvio,
Recursosporcentagem = portfolio.eficiente@portfolio@portfolio$weights,
Data_analise = Fundos$Data_analise)
Markowitz$Recursos = Markowitz$Max_recursos*Markowitz$Recursosporcentagem
return(Markowitz)
}
#Markowitz = otimizacao(my_dt,Fundos)
# Os indices de fundos que possuem alguma alocação
#idx = which(Markowitz$Recursos!=0)
#Fundos_alocados = filter(Markowitz , Markowitz$Recursos !=0)
i=1
perda = list()
TESTE= list()
for (i in 1:length(serie)) {
my_dt[[i]]$DT_COMPTC = as.Date.character(my_dt[[i]]$DT_COMPTC)
TESTE[[i]] = filter(my_dt[[i]], my_dt[[i]]$DT_COMPTC == "2022-05-31")
}
i=1
a=0
b=0
for (i in 1:length(previsao)) {
perda[[i]] = (tail(previsao[[i]]$lower,1) - TESTE[[i]]$VL_QUOTA)*Fundos_alocados$Recursos[i]
a[i] = tail(previsao[[i]]$lower,1)
b[i]= TESTE[[i]]$VL_QUOTA
}
a = cbind(a,b)
